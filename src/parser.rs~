/*
In C, there are both expressions and statements.
A statement must have a semicolon, and optionally an expression.

I think at the repl, I am thinking that it should print the result of the
expression if I just write an expression, but also do the same for a statement.
Maybe only one expression per line, and then allow multiple statements?


I am thinking that I should return a list of statements to allow multiple
statements in one line.
*/

use crate::lexer::Token;

#[derive(PartialEq, Debug)]
pub enum Expr {
    Empty,
    CInt(i32),
}

impl Expr {
    pub fn parse(tokens: &[Token]) -> Vec<Expr> {
        let mut statements: Vec<Expr> = Vec::new();
        let mut expr = Expr::Empty;
        
        for token in tokens {
            match token {
                Token::TokInt(i) => expr = Expr::CInt(*i),
                Token::TokSemicolon => statements.push(expr.clone()),
            }
        }

        if statements.len() == 0 {
            statements.push(expr);
        }

        statements
    }

    fn build_expr(Iter<Token>, &mut Vec<Expr>) -> Option<Iter<Token>>> {
        let mut expr = Expr::Empty;

        loop {
            if let Some(e) = iter.next() {
                match e {
                    Token::TokInt(i) => expr = Expr::CInt(*i),
                    Token::TokSemicolon => {
                        statements.push(e);
                        break;
                    }
                }
            } else {
                statements.push
            }
        }
    }
}


#[cfg(test)]
mod tests {
    use crate::lexer::Token::*;
    use crate::parser::Expr;

    #[test]
    fn parse_nothing() {
        assert_eq![Expr::parse(&vec![]), vec![Expr::Empty]];
    }
    
    #[test]
    fn parse_int32_semicolon() {
        assert_eq![Expr::parse(&vec![TokInt(10), TokSemicolon]),
                   vec![Expr::CInt(10)]];
    }

    #[test]
    fn parse_int32_nosemicolon() {
        assert_eq![Expr::parse(&vec![TokInt(-42)]), vec![Expr::CInt(-42)]];
    }

    #[test]
    fn parse_int32_many() {
        assert_eq![Expr::parse(&vec![TokInt(10), TokSemicolon,
                                    TokInt(-42), TokSemicolon,
                                    TokInt(3333), TokSemicolon,
                                    TokSemicolon,
                                    TokSemicolon]),
                   vec![Expr::CInt(10), Expr::CInt(-42), Expr::CInt(3333)]];
    }
    
}
